<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Поиск вопросов из document.txt</title>
<style>
  :root{
    --q-bg:#cce6ea;        /* бирюзовый фон для вопроса */
    --q-border:#b7d3d7;    /* граница для вопроса */
    --match:#fff59e;       /* подсветка совпавших слов */
    --ok:#16a34a;          /* зелёный для (+) */
  }
  body { font-family: Arial, sans-serif; padding: 20px; line-height: 1.45; }
  h2 { margin: 0 0 12px; }
  #search { width: 100%; padding: 10px; font-size: 16px; margin-bottom: 16px; }
  .question {
    background: var(--q-bg);
    border: 1px solid var(--q-border);
    border-radius: 8px;
    padding: 12px 14px;
    margin: 0 0 6px;
    font-weight: 600;
  }
  .answers { margin: 6px 0 18px 24px; }
  .answer { margin-bottom: 4px; white-space: pre-wrap; }
  mark.match { background: var(--match); padding: 0 .1em; }
  .plus { color: var(--ok); font-weight: 700; }
  .muted { color:#6b7280 }
</style>
</head>
<body>

<h2>Поиск вопросов из файла document.txt</h2>
<input type="text" id="search" placeholder="Введите часть вопроса для поиска..." disabled />
<div id="results">Загрузка файла…</div>

<script>
  const searchInput = document.getElementById('search');
  const resultsDiv  = document.getElementById('results');
  let QA = [];

  // Нормализация строк для сопоставления
  const norm = s => (s||'')
    .toLowerCase()
    .replace(/ё/g,'е')
    .replace(/[^\p{L}\p{N}\s]+/gu,' ')
    .replace(/\s+/g,' ')
    .trim();

  const escapeReg = s => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

  function highlightWords(text, query){
    let out = text;
    const tokens = norm(query).split(' ').filter(t => t.length > 2);
    tokens.forEach(t => {
      const re = new RegExp(`(${escapeReg(t)})`, 'gi');
      out = out.replace(re, '<mark class="match">$1</mark>');
    });
    return out;
  }

  // Парсер: якоримся на строке "1)" и берём 1–3 строки ВПЕРЕДИ неё как текст вопроса.
  // Строки с "(+)" в вопрос НЕ попадают.
  function parseFromTxt(txt){
    const raw = txt.split(/\r?\n/).map(l => l.trim());
    const lines = raw.filter(l => l !== ''); // убираем пустые
    const res = [];

    for (let i = 0; i < lines.length; i++){
      if (/^1\)/.test(lines[i])) {
        // собрать ответы
        const answers = [];
        let j = i;
        while (j < lines.length && /^\d\)/.test(lines[j])) {
          answers.push(lines[j]);
          j++;
        }

        // собрать вопрос: до i идут ненумерованные строки.
        // берём максимум 3 последних, не содержащих "(+)".
        const qParts = [];
        let back = i - 1;
        while (back >= 0 && !/^\d\)/.test(lines[back]) && qParts.length < 3){
          if (!/\(\+\)/.test(lines[back]) && lines[back] !== '') {
            qParts.unshift(lines[back]); // добавляем в начало, чтобы сохранить порядок
          } else {
            // если упёрлись в строку с (+), прекращаем расширять вопрос
            break;
          }
          back--;
        }
        const question = qParts.join(' ').replace(/\s+/g,' ').trim();

        if (question && answers.length){
          res.push({ question, answers });
        }

        i = j - 1; // перескакиваем к концу блока с ответами
      }
    }
    return res;
  }

  function render(list, query){
    resultsDiv.innerHTML = '';
    if (!list.length){
      resultsDiv.innerHTML = '<span class="muted">Ничего не найдено.</span>';
      return;
    }

    list.forEach(item => {
      const q = document.createElement('div');
      q.className = 'question';
      q.innerHTML = highlightWords(item.question, query);

      const aWrap = document.createElement('div');
      aWrap.className = 'answers';

      item.answers.forEach(ans => {
        const div = document.createElement('div');
        div.className = 'answer';
        // зелёный плюс
        div.innerHTML = ans.replace(/\(\+\)/g,'<span class="plus">(+)</span>');
        aWrap.appendChild(div);
      });

      resultsDiv.appendChild(q);
      resultsDiv.appendChild(aWrap);

      // плавный скролл к первому результату
      q.scrollIntoView({ behavior: 'smooth', block: 'center' });
    });
  }

  // Загрузка данных
  fetch('document.txt')
    .then(r => { if(!r.ok) throw new Error('Не удалось загрузить document.txt'); return r.text(); })
    .then(text => {
      QA = parseFromTxt(text);
      searchInput.disabled = false;
      resultsDiv.innerHTML = '<span class="muted">Данные загружены. Можно искать.</span>';
    })
    .catch(e => resultsDiv.textContent = 'Ошибка: ' + e.message);

  // Поиск
  searchInput.addEventListener('input', () => {
    const q = searchInput.value.trim();
    if (!q){ resultsDiv.innerHTML = ''; return; }
    const nq = norm(q);
    const filtered = QA.filter(x => norm(x.question).includes(nq));
    render(filtered, q);
  });
</script>
</body>
</html>
