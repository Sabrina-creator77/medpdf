<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title></title>
<style>
  :root{
    --q-bg:#cce6ea;
    --q-border:#b7d3d7;
    --match:#fff59e;
    --ok:#16a34a;
  }
  body { font-family: Arial, sans-serif; padding: 20px; line-height: 1.45; }
  #search { width: 100%; padding: 10px; font-size: 16px; margin-bottom: 16px; }
  .question {
    background: var(--q-bg);
    border: 1px solid var(--q-border);
    border-radius: 8px;
    padding: 12px 14px;
    margin: 0 0 6px;
    font-weight: 600;
  }
  .answers { margin: 6px 0 18px 24px; }
  .answer { margin-bottom: 4px; white-space: pre-wrap; }
  mark.match { background: var(--match); padding: 0 .1em; }
  .plus { color: var(--ok); font-weight: 700; }
  .muted { color:#6b7280 }
</style>
</head>
<body>

<input type="text" id="search" placeholder="Введите часть вопроса для поиска..." disabled />
<div id="results">Загрузка файла…</div>

<script>
  const searchInput = document.getElementById('search');
  const resultsDiv  = document.getElementById('results');
  let QA = [];

  const norm = s => (s||'')
    .toLowerCase()
    .replace(/ё/g,'е')
    .replace(/[^\p{L}\p{N}\s]+/gu,' ')
    .replace(/\s+/g,' ')
    .trim();

  const escapeReg = s => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

  function highlightWords(text, query){
    let out = text;
    const tokens = norm(query).split(' ').filter(t => t.length > 2);
    tokens.forEach(t => {
      const re = new RegExp(`(${escapeReg(t)})`, 'gi');
      out = out.replace(re, '<mark class="match">$1</mark>');
    });
    return out;
  }

  function parseFromTxt(txt){
    const raw = txt.split(/\r?\n/).map(l => l.trim());
    const lines = raw.filter(l => l !== '');
    const res = [];

    for (let i = 0; i < lines.length; i++){
      if (/^1\)/.test(lines[i])) {
        const answers = [];
        let j = i;
        while (j < lines.length && /^\d\)/.test(lines[j])) {
          answers.push(lines[j]);
          j++;
        }

        const qParts = [];
        let back = i - 1;
        while (back >= 0 && !/^\d\)/.test(lines[back]) && qParts.length < 3){
          if (!/\(\+\)/.test(lines[back]) && lines[back] !== '') {
            qParts.unshift(lines[back]);
          } else break;
          back--;
        }
        const question = qParts.join(' ').replace(/\s+/g,' ').trim();

        if (question && answers.length){
          res.push({
            question,
            normQ: norm(question),
            answers
          });
        }

        i = j - 1;
      }
    }
    return res;
  }

  function render(list, query){
    resultsDiv.innerHTML = '';
    if (!list.length){
      resultsDiv.innerHTML = '<span class="muted">Ничего не найдено.</span>';
      return;
    }

    list.forEach((item, idx) => {
      const q = document.createElement('div');
      q.className = 'question';
      q.innerHTML = highlightWords(item.question, query);

      const aWrap = document.createElement('div');
      aWrap.className = 'answers';

      item.answers.forEach(ans => {
        const div = document.createElement('div');
        div.className = 'answer';
        const text = ans.replace(/\(\+\)/g,'<span class="plus">(+)</span>');
        div.innerHTML = highlightWords(text, query);
        aWrap.appendChild(div);
      });

      resultsDiv.appendChild(q);
      resultsDiv.appendChild(aWrap);

      if (idx === 0) {
        q.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    });
  }

  fetch('document.txt')
    .then(r => { if(!r.ok) throw new Error('Не удалось загрузить document.txt'); return r.text(); })
    .then(text => {
      QA = parseFromTxt(text);
      searchInput.disabled = false;
      resultsDiv.innerHTML = '<span class="muted">Данные загружены. Можно искать.</span>';
    })
    .catch(e => resultsDiv.textContent = 'Ошибка: ' + e.message);

  searchInput.addEventListener('input', () => {
    const q = searchInput.value.trim();
    if (!q){ resultsDiv.innerHTML = ''; return; }
    const words = norm(q).split(' ').filter(Boolean);
    const filtered = QA.filter(x => words.every(w => x.normQ.includes(w)));
    render(filtered, q);
  });
</script>
</body>
</html>
